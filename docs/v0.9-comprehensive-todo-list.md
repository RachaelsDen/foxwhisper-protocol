# FoxWhisper v0.9 Comprehensive Todo List
*Conformance, Tooling, and Ecosystem Build-Out*

## Overview
This todo list captures all tasks required to complete FoxWhisper v0.9 as defined in the roadmap. The primary goal is to enable multi-implementation compatibility and real-world deployment readiness.

## ðŸŽ¯ Current Progress Summary (as of December 2025)

### âœ… **Completed Major Milestones:**
- **4.1.1 Canonical CBOR Examples** - âœ… COMPLETED
  - âœ… CBOR encoding examples for all message types
  - âœ… CBOR tag usage and canonicalization rules
  - âœ… Test vectors for handshake, DR, group, media messages
  - âœ… Cross-language validation (Go, Python, Node.js, Erlang)
  - âœ… CBOR validation schema/documentation

- **4.4.1 Serialization Validators** - âœ… COMPLETED
  - âœ… CBOR validation tools (Go, Python, Node.js, Erlang)
  - âœ… Message structure validators
  - âœ… Canonical encoding checkers
  - âœ… Cryptographic material validators
  - âœ… Cross-platform compatibility tests
  - âœ… Command-line interfaces

### ðŸ“Š **Completion Status:**
- **Section 4.1**: 3/3 tasks complete (100%)
- **Section 4.2**: 6/6 tasks complete (100%)
- **Section 4.3**: 2/3 tasks complete (67%)
- **Section 4.4**: 1/3 tasks complete (33%)

### ðŸŽ¯ **Key Achievements:**
1. **Multi-Language CBOR Validation** - Go, Python, Node.js, Erlang all working
2. **Canonical CBOR Encoding** - Consistent across platforms
3. **Test Vector Suite** - Comprehensive handshake message vectors
4. **Cross-Language Compatibility** - All validators produce identical results
5. **Development Tooling** - Complete validation and testing framework
6. **Multi-Language Test Generation** - Python, Go, JavaScript generators
7. **Comprehensive Test Coverage** - End-to-end, DR, group, media, epoch vectors
8. **Hybrid Handshake Realized** - Minimal JS client/server now run real X25519+Kyber (PQClean) with crypto_profile telemetry and minimal_e2e_status artifact enforced in CI

---

## 4.1 Conformance Test Suite

### 4.1.1 Canonical CBOR Examples
- [x] Create canonical CBOR encoding examples for all message types
- [x] Document CBOR tag usage and canonicalization rules
- [x] Provide test vectors for handshake messages
- [x] Provide test vectors for device record (DR) messages
- [x] Provide test vectors for group management messages
- [x] Provide test vectors for media key distribution
- [x] Validate CBOR examples across multiple programming languages
- [x] Create CBOR validation schema/documentation

### 4.1.2 End-to-End Test Vectors
- [x] Handshake test vectors (initial setup, device addition)
- [x] DR (Device Record) test vectors (backup, restore, reset)
- [x] Group messaging test vectors (creation, join, leave)
- [x] Media encryption test vectors (key derivation, frame protection)
- [x] Epoch transition test vectors
- [x] Multi-device synchronization test vectors
- [x] Cross-platform validation of all test vectors
- [x] Multi-language test vector generators (Python, Go, JavaScript)

### 4.1.3 Replay and Poisoning Test Scenarios
- [x] Replay attack detection test cases
- [x] Message replay window boundary tests
- [x] Poisoning message injection tests
- [x] Epoch fork detection scenarios
- [x] Malformed EARE (Epoch Authenticity Record) tests
- [x] Anti-poisoning rule validation tests
- [x] Replay storm simulation test cases

---

## 4.2 Fuzzing & Adversarial Simulation Framework

### 4.2.1 Malformed Packet Fuzzing
- [x] Design fuzzing framework architecture
- [x] Implement CBOR structure fuzzer
- [x] Create malformed message generators
- [x] Test protocol resilience to corrupted headers
- [x] Test handling of oversized messages
- [x] Test behavior with missing required fields
- [x] Test invalid cryptographic material handling
- [x] Integrate with AFL/LibFuzzer or similar tools

### 4.2.2 Replay Storm Simulation
- [x] Design replay storm simulation framework
- [x] Implement high-volume replay generator
- [x] Test replay window overflow scenarios
- [x] Measure performance under replay attacks
- [x] Test memory usage during replay storms
- [x] Validate replay detection accuracy
- [x] Create replay storm mitigation tests

### 4.2.3 Epoch Fork Stress Tests
- [x] Design epoch fork simulation framework
- [x] Implement concurrent epoch creation tests
- [x] Test epoch chain validation under stress (long-run / high-volume)
- [x] Simulate network partition scenarios
- [x] Test epoch reconciliation procedures
- [x] Validate fork detection accuracy
- [x] Measure performance during fork resolution (wall_time_ms, optional --stress)
- [x] Add fork+replay-drop scenarios (enforce dropping losing-branch messages post-reconciliation)
- [x] Add skew-visibility scenarios (fork becomes observable only after controller skew/late delivery) to guard timing regressions
- [x] Add CI perf thresholds for stress-tagged runs and a nightly high-volume soak (>1k events, track wall_time_ms)
- [x] Add corpus schema validation in coordinator to catch field drift across shims

### 4.2.4 Multi-Device Desync Simulators
- [x] Design multi-device desync framework
- [x] Implement device state divergence simulator
- [x] Test DR synchronization failures
- [x] Simulate clock skew between devices
- [x] Test partial message delivery scenarios
- [x] Validate device recovery procedures
- [x] Test backup/restore consistency
- [x] Add replay vs DR-state divergence scenarios (stale DR applied while others advance)
- [x] Add partial delivery + delayed backup/restore cases to ensure conflict-free recovery
- [x] Add skewed-clock + missing steps scenarios to catch time-based DR validation regressions

### 4.2.5 Corrupted EARE Injection
- [x] Design EARE corruption test framework
- [x] Implement invalid signature/PoP generators (structural checks in shims)
- [x] Test hash chain breakage scenarios
- [x] Simulate EARE tampering attacks (truncated/extra fields, altered payload bytes)
- [x] Test epoch authenticity validation (structural error surfacing)
- [x] Validate error handling for corrupted EAREs
- [x] Measure impact of EARE corruption (rejected/accepted metrics)

### 4.2.6 SFU Abuse Patterns
- [x] Design SFU abuse simulation framework and corpus
- [x] Implement unauthorized SFU access tests (ghost/impersonation/unauthorized subscribe)
- [x] Test media key extraction attempts (stale key reuse/steal_key)
- [x] Simulate SFU compromise scenarios (duplicate routes, replay tracks, rogue routing)
- [x] Test participant authentication bypasses (impersonation)
- [x] Validate SFU authorization mechanisms (layer/simulcast spoof, bitrate abuse guards)
- [x] Test media stream hijacking attempts (replay/dup track, simulcast spoof)

---

## 4.3 Reference Implementations

### 4.3.1 Minimal Reference Client

**Working decisions (2025-12-08):**
- Group messaging reuses the existing JOIN/DATA routing; treat `room_id` as `group_id` and keep the group layer purely as an in-memory crypto state machine (no new wire types in the Node harness).
- Media vectors already exist (e.g., `tests/common/handshake/media_encryption_test_vectors.json`); consume them directly and only add derivative fixtures when needed.
- Key schedule and crypto conformance tests should compare hashed/tagged digests of keys/IV/AAD/ciphertext, not raw key material.
- Phase 1 done: real crypto wired to labeled handshake secret + deterministic IV/AAD; DR backup/restore/reset semantics validated; handshake/DR digest artifacts emitted in `clients/minimal-js/test-output/handshake_dr_crypto_status.json` and `dr_vectors_crypto_status.json`.

- [x] Choose implementation language (TypeScript/JavaScript)
- [x] Design client architecture (minimal library with WebSocket transport)
- [x] Implement core cryptographic operations (Phase 1: HKDF-SHA256, deterministic IV/AAD, labeled handshake secret wired)
- [x] Implement handshake protocol
- [x] Implement device record management (backup/restore/reset semantics validated against shared vectors)
- [x] Implement group messaging (group harness over JOIN/DATA with deterministic IV/AAD, vector digests emitted)
- [x] Implement media encryption/decryption (media harness with vector digests; opaque vectors treated as fixtures)
- [x] Add comprehensive error handling
- [x] Create usage documentation
- [x] Validate against conformance test suite (vector-driven harness: handshake/DR/group/media + digest outputs in clients/minimal-js/test-output)
- [x] Switch hybrid handshake to real X25519+Kyber keys end-to-end (client + server + vectors); shared-secret HKDF now driven by X25519+Kyber, server encapsulates per handshake, crypto_profile logged, minimal_e2e_status.json artifact emitted and enforced in CI

#### 4.3.1.a Minimal JS Node Test Harness Milestones

- **M0 â€“ Scope & Spec Alignment (Node Test Harness)**
  - [x] Decide that the minimal client is a Node-only test harness for v0.9 (not a production app).
  - [x] Confirm crypto parameter sets per v0.8.1: hybrid X25519+Kyber; HKDF-SHA256 (32-byte); AES-256-GCM; deterministic 96-bit IV = Truncate_96bits(SHA256(context)); AAD = SHA256(canonicalCBOR(header)); ed25519 for group/EARE signatures.
  - [x] Map shared test vector files in `tests/common/*` to client responsibilities (handshake, DR, group, media):
    - Handshake/CBOR structure & tags: `tests/common/handshake/cbor_test_vectors.json`, `cbor_test_vectors_fixed.json` â†’ client must encode/decode `HANDSHAKE_INIT/RESPONSE/COMPLETE` with correct tags and canonical CBOR.
    - Handshake flow: `tests/common/handshake/end_to_end_test_vectors.json`, `end_to_end_test_vectors_js.json`, `end_to_end_test_vectors_go.json` â†’ client handshake state machine and message ordering must match these flows.
    - Device Record (DR): `tests/common/handshake/dr_test_vectors.json` â†’ client DR backup/restore/reset and multi-device sync operations must align with these structures and semantics.
    - Group messaging: `tests/common/handshake/group_messaging_test_vectors.json` â†’ client group session setup, sender key distribution, and group message handling must follow these patterns.
    - Media: `tests/common/handshake/media_encryption_test_vectors.json` â†’ client media key derivation and frame protection helpers must be able to consume/produce messages consistent with these vectors.
    - Epoch / multi-device: `tests/common/handshake/epoch_transition_test_vectors.json`, `multi_device_sync_test_vectors.json`, `replay_poisoning_test_vectors.json` â†’ client-side state transitions, epoch handling, and replay protection must not contradict these scenarios (even when primarily enforced by validators.
- **M1 â€“ Handshake & Device Record Conformance Harness**
  - [x] Implement or refine a crypto wrapper for handshake/DR using the chosen primitives.
  - [x] Wire handshake flows to the wrapper (deterministic HKDF/AES-GCM); pending: swap transcript stub for real X25519+Kyber shared secret + updated vectors.
  - [x] Implement DR create/update/validate logic with version monotonicity and integrity checks.
  - [x] Add Node tests that directly consume handshake and DR vectors and emit JSON-style pass/fail summaries for cross-language comparison.
- **M2 â€“ Group Messaging Harness**
  - [x] Define in-code group model (group IDs, epoch reference, per-participant state, sender keys) via JOIN/DATA harness.
  - [x] Implement group key derivation and AEAD with replay enforcement; emit digests.
  - [x] Add tests that consume group messaging vectors and compare behavior (digests) against other implementations.
- **M3 â€“ Media Encryption/Decryption Harness**
  - [x] Clarify media mode: frame-level AEAD with deterministic IV/AAD; vectors are opaque/random, treated as fixtures.
  - [x] Implement media key derivation and frame encrypt/decrypt helpers; emit digests.
  - [x] Add tests using existing media vectors; compare digests (not ciphertext) to avoid raw key leakage.
- **M4 â€“ Key Schedule Consistency, RNG/Key Storage, Conformance Integration**
  - [x] Add digest-only key-schedule test (handshake â†’ group â†’ media â†’ DR) and artifact `key_schedule_status.json`.
  - [x] Ensure RNG uses Node crypto; harness is test-only, with note to use hardware-backed keys in production.
  - [x] Integrate minimal client harness into CI; digest artifacts enforced in `validate-node-minimal.sh`.

### 4.3.2 Minimal Server Reference (Metadata-Only)
- [x] Design server architecture (metadata-only)
- [x] Implement device registration service
- [x] Implement group management service
- [x] Implement message routing metadata
- [x] Implement compliance/moderation interfaces
- [x] Add audit logging capabilities
- [x] Create deployment documentation
- [x] Validate security properties

### 4.3.3 SFU Reference Handler
- [ ] Design SFU architecture
- [ ] Implement SFU authentication
- [ ] Implement media key distribution
- [ ] Implement stream routing logic
- [ ] Implement participant management
- [ ] Add media transcript integrity
- [ ] Create SFU deployment guide
- [ ] Validate media security properties

---

## 4.4 Interoperability Tools

### 4.4.1 Serialization Validators
- [x] Design CBOR validation tool
- [x] Implement message structure validator
- [x] Create canonical encoding checker
- [x] Add cryptographic material validator
- [x] Implement cross-platform compatibility tests
- [x] Create command-line interface
- [x] Add integration with CI/CD pipelines

### 4.4.2 Epoch-Chain Validators
- [ ] Design epoch chain validation tool (corpus-driven, cross-language)
- [ ] Implement EARE verification logic (sig/PoP) and hash chain integrity checker
- [ ] Add epoch transition validator and fork detection algorithms (encode reconciliation policy)
- [ ] Add corpus-to-validator CI integration using tests/common/adversarial/epoch_forks.json
- [ ] Create epoch visualization tools
- [ ] Add performance analysis and thresholds (wall_time_ms) for stress-tagged runs

### 4.4.3 Key Schedule Visualization Tool
- [ ] Design key schedule visualization framework
- [ ] Implement key derivation tree viewer
- [ ] Create epoch key flow diagrams
- [ ] Add media key schedule visualization
- [ ] Implement device key relationship viewer
- [ ] Create interactive key exploration tool
- [ ] Add export capabilities for documentation

### 4.4.4 Crypto Conformance Validators
- [ ] Handshake crypto checks: recompute X25519+Kyber hybrid secret, derive `handshake_secret` via HKDF-SHA256 with spec labels, and compare against shared vectors.
- [ ] DR/ratchet checks: recompute message keys and chain keys via HKDF-SHA256 labels ("FoxWhisper-Message", "FoxWhisper-Chain"); verify AES-256-GCM encrypt/decrypt with deterministic IV and AAD.
- [ ] Media checks: recompute `media_epoch_key` and `frame_key` via HKDF-SHA256 ("FW-MediaEpochKey", "FW-FrameKey"); recompute deterministic IV = Truncate_96bits(SHA256(call_id || participant_id || stream_id || frame_sequence)); verify AES-256-GCM with correct AAD.
- [ ] Group/EARE signature checks: verify ed25519 signatures on group key distribution and EARE examples; confirm EARE hash-chain linkage per spec.
- [ ] Cross-language crypto diff harness: emit JSON summaries (hashed/tagged keys, IV, AAD, ciphertext digest) per language and diff to detect drift from v0.8.1.

---

## Additional Cross-Cutting Tasks

### Documentation and Standards
1. [ ] Update specification with v0.9 conformance requirements and chosen crypto parameters (KEM/KDF/AEAD, nonce/AAD rules, media mode)
2. [ ] Document epoch fork/replay/DR semantics and reconciliation policy; align with epoch-chain validator expectations
3. [ ] Capture SFU auth/key lifecycle and media transcript integrity format
4. [ ] Create conformance certification process documentation
5. [ ] Write interoperability testing guidelines
6. [ ] Document reference implementation architectures and secure key storage expectations (hardware-backed identity keys)
7. [ ] Create security analysis documentation for all tools (include side-channel posture)
8. [ ] Write deployment and integration guides (key rotation, DR restore, rollback, backup hygiene)

### Testing Infrastructure
1. [ ] Set up automated testing pipeline
2. [ ] Create continuous integration for all reference implementations
3. [ ] Implement cross-platform compatibility matrix (handshake/DR/group/media/SFU)
4. [ ] Set up performance benchmarking framework (handshake, replay storms, SFU paths)
5. [ ] Create security audit automation and schedule audit gate
6. [ ] Implement regression testing for all components
7. [ ] Add SBOM generation and artifact signing (where applicable)

### Community and Ecosystem
1. [ ] Create contribution guidelines for v0.9
2. [ ] Set up issue tracking templates
3. [ ] Create community testing framework
4. [ ] Design implementation certification program
5. [ ] Create developer onboarding materials
6. [ ] Set up ecosystem communication channels

### Release Preparation
1. [ ] Create v0.9 release notes
2. [ ] Prepare migration guide from v0.8
3. [ ] Create compatibility matrix (publish thresholds)
4. [ ] Prepare security advisory documentation
5. [ ] Create implementation checklist
6. [ ] Prepare announcement materials

---

## Success Criteria

### Technical Milestones
- [ ] All conformance tests pass across multiple implementations
- [ ] Fuzzing framework achieves >95% code coverage
- [ ] Reference implementations interoperate without issues
- [ ] Interoperability tools validate all protocol aspects
- [ ] Security audit passes with no critical findings

### Ecosystem Readiness
- [ ] At least 2 independent implementations exist
- [ ] Conformance certification process is functional
- [ ] Developer documentation is comprehensive
- [ ] Community testing framework is active
- [ ] Migration path from v0.8 is validated

---

## Timeline Estimates

### Phase 1: Foundation (4-6 weeks)
- Conformance test suite core
- Basic fuzzing framework
- Reference client foundation

### Phase 2: Implementation (6-8 weeks)
- Complete reference implementations
- Full fuzzing and simulation framework
- Interoperability tools

### Phase 3: Validation (4-6 weeks)
- Cross-implementation testing
- Security auditing
- Documentation completion

### Phase 4: Release (2-4 weeks)
- Community testing
- Release preparation
- Ecosystem onboarding

**Total Estimated Timeline: 16-24 weeks**

---

## Dependencies and Prerequisites

### Technical Dependencies
- v0.8.1 specification must be finalized
- Formal verification artifacts from v0.8 must be available
- Cryptographic libraries must support required primitives
- Testing infrastructure must be in place

### Resource Requirements
- Cryptography expertise for security validation
- Software engineering resources for implementations
- Security auditing resources
- Documentation and technical writing support

---

*This todo list will be updated as v0.9 development progresses and new requirements emerge.*