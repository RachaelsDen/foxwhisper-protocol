# FoxWhisper v0.9 – 4.3.3 SFU Reference Handler TODO

This document expands **4.3.3 SFU Reference Handler** from `docs/v0.9-comprehensive-todo-list.md` into an actionable, Node.js–focused plan.

Scope:
- Language: **TypeScript/Node.js**
- Codebase: `servers/minimal-js` (and minimal additions to `docs/` / validation where needed)
- Role: **reference/test SFU**, not production.
- Alignment:
  - SFU auth model in `spec/e2ee-protocol-specification-v0.8.1.md` (§3 Media Profile v1, §3.3 SFU Authentication Framework).
  - Media test vectors in `tests/common/handshake/media_encryption_test_vectors.json`.
  - SFU abuse corpus + oracles in `tests/common/adversarial/sfu_abuse.json`, `validation/common/simulators/sfu_abuse.py`, and language shims.

Status legend:
- `[ ]` not started
- `[-]` in progress
- `[x]` completed

---

## 0. Prerequisites & Grounding

**Goal:** Ensure we have a shared mental model before building the SFU handler.

- [x] 0.1 Read SFU-related spec sections and summarize:
  - `spec/e2ee-protocol-specification-v0.8.1.md`:
    - Media Profile v1 (SFU-based) section.
    - §3.3 SFU Authentication Framework and Frame Authentication.
  - `docs/fuzzing-adversarial-architecture.md` §4.2.6 SFU Abuse.
  - `docs/foxwhisper_roadmap.md` items referencing SFU.
  - Summary (2025-12-09):
    - Media Profile v1: SFU routes ciphertext only; end-to-end crypto stays on endpoints; key ladder callKey→streamKey→mediaEpochKey→frameKey; deterministic IV on call/participant/stream/sequence; frame auth tags are HMAC-SHA256 over header/payload/sequence; per-epoch rekeying preserves FS/PCS.
    - SFU auth framework: client auth key = HKDF(handshake_secret, info="FW-SFU-ClientAuth"||client_id); tokens are HMAC(call_id||client_id||timestamp||nonce) with short expiry, nonce cache, and skew window; SFU tokens use an SFU secret key; replays/skewed tokens rejected.
    - Fuzzing SFU abuse: corpus at `tests/common/adversarial/sfu_abuse.json` targets unauthorized key requests, hijacked streams, etc.; Node validator is first-class, Go shim follows.
    - Roadmap SFU focus: auth rules, call→stream key derivation, join/leave + transcript integrity, SFU buffering/scheduling, and the reference handler + abuse testing deliverables for v0.9.
- [x] 0.2 Review existing SFU-related tooling:
  - Python oracle: `validation/common/simulators/sfu_abuse.py`.
  - Node validator shim: `validation/nodejs/validators/sfu_abuse.js`.
  - SFU corpus: `tests/common/adversarial/sfu_abuse.json`.
  - Findings (2025-12-09):
    - Corpus schema: `sfu_context` (sfu_id, room_id, expected_participants, auth_mode), participants with `authz_tokens` + tracks, sorted `timeline` events (join/publish/subscribe/ghost_subscribe/impersonate/replay_track/dup_track/simulcast_spoof/bitrate_abuse/key_rotation_skip|stale_key_reuse/steal_key), and `expectations` caps plus `expected_errors`.
    - Python oracle: error set {UNAUTHORIZED_SUBSCRIBE, IMPERSONATION, KEY_LEAK_ATTEMPT, STALE_KEY_REUSE, DUPLICATE_ROUTE, REPLAY_TRACK, HIJACKED_TRACK, SIMULCAST_SPOOF, BITRATE_ABUSE}; tokens gate join/publish/subscribe; first error time = detection_ms; metrics count unauthorized_tracks, replayed/duplicate tracks, simulcast/bitrate abuse, key_leak_attempts, etc.; evaluate enforces detection/latency + metric ceilings.
    - Node shim: mirrors oracle flow + error set, emits `nodejs_sfu_abuse_summary.json`, exits non-zero on failures; metrics match Python fields (accepted/rejected tracks, latency, spoof/bitrate counts, key_leak_attempts).
- [x] 0.3 Review media-related pieces:
  - Media vectors: `tests/common/handshake/media_encryption_test_vectors.json`.
  - Media key generation: `tools/generators/generate_media_test_vectors.py`.
  - Minimal client media harness: `clients/minimal-js/src/media*` (and associated tests).
  - Findings (2025-12-09):
    - Vectors cover `key_derivation`, `frame_protection`, and `key_distribution`; explicit fields for session/media contexts, HKDF salt, IV, AAD, auth_tag, and SFU context (sfu_id/participant_id/session_type) with KEY_DISTRIBUTE + KEY_ACK steps and expected results.
    - Generator script emits random base64 material with the same structure and basic field-presence validation; default output path `../test-vectors/handshake/media_encryption_test_vectors.json`.
    - Minimal client helper `media.ts`: HKDF label "FW-MediaEpochKey" using provided salt; AES-256-GCM encrypt/decrypt with supplied IV/AAD; deterministic IV via SHA256(call||participant||stream||frameSeq) truncated to 12 bytes; frameHeaderAAD = SHA256(canonical CBOR header). Align SFU transcript digests with these helpers.
- [-] 0.4 Lock in SFU integration mode for v0.9:
  - [x] Use **in-process** SFU handler (no extra network hop) wired behind `MinimalServer`’s routing.
  - [ ] (Explicitly non-goal for v0.9) Dedicated SFU-side WebSocket endpoint in `servers/minimal-js` for media.
  - Rationale: Avoid extra sockets/transport confusion; focus purely on SFU state + decisions; make corpus replay into `MinimalSfu` trivial.
- [x] 0.5 Write a short design note (can be in this file or a brief `docs/sfu-reference-handler-design.md`) capturing:
  - The SFU’s trust model (logically untrusted, routes ciphertext only).
  - Explicit constraints: **no plaintext media** and **no raw keys** ever touch SFU code (only IDs / entitlements / digests).
  - Assumptions about how it receives media frames and auth tokens.
  - A minimal state machine for participants, tracks, and subscriptions.
  - Notes (2025-12-09): documented in `docs/sfu-reference-handler-design.md`; SFU is an in-process, untrusted router with HMAC-based auth tokens (nonce+timestamp replay window), state maps for participants/tracks/subscriptions/keyGrants/nonceCache/transcript, APIs for authenticate/join/leave/publish/subscribe/onFrame/grantMediaKey/requestMediaKey/getTranscript/resetTranscript, and error codes aligned with the SFU abuse corpus plus transcript digests derived from canonical CBOR hashes.

**Artifacts:**
- Design bullets embedded here or a small `docs/sfu-reference-handler-design.md`.

---

## 1. SFU Architecture ("Design SFU architecture")

**Goal:** Define concrete types, state, and APIs for the Node-based SFU handler in `servers/minimal-js`.

### 1.1 Module & type layout

- [x] 1.1.1 Create `servers/minimal-js/src/sfu.ts` with a `MinimalSfu` class skeleton:
  - Constructor config (`SfuConfig`):
    - `roomId` / optional `callId`.
    - `logger` and `auditLogger` functions (mirroring `MinimalServer` style).
    - `sfuSecretKey` or `sfuKeyProvider` (for SFU → client token generation, if needed).
    - Policy knobs (e.g., max subscribers per track, allowed layers, abuse thresholds).
  - Core public methods:
    - `join(participantId, authContext)` – invoked when participant wants media routing.
    - `leave(participantId)` – media-level termination.
    - `publishTrack(participantId, trackInfo)` – register media track + layers.
    - `subscribeTrack(subscriberId, trackId, options)` – request subscription; returns routing decision / error.
    - `onFrame(frameMeta)` – invoked for each media frame to update transcript and metrics.
  - Notes (2025-12-09): `servers/minimal-js/src/sfu.ts` adds MinimalSfu with stubbed auth, join/leave, publish/subscribe, onFrame transcript hook, key grant/request, metrics, and logging/audit hooks.
- [x] 1.1.2 Define supporting types in `servers/minimal-js/src/types.ts` or a new `sfu_types.ts`:
  - `SfuParticipant`, `SfuTrack`, `SfuSubscription`, `SfuFrameMeta` (header subset: `call_id`, `participant_id`, `stream_id`, `frame_sequence`, `media_epoch`, etc.).
  - A **single central error-code enum/union** aligned with corpus/oracles (e.g., "UNAUTHORIZED_SUBSCRIBE" | "IMPERSONATION" | ...) shared by:
    - `MinimalSfu` implementation,
    - SFU abuse harness/tests,
    - Any Node-based validator glue.
  - Notes (2025-12-09): `servers/minimal-js/src/sfu_types.ts` exports typed config/policy/auth contexts, central `SfuErrorCode` union with `SFU_ERROR_CODES`, frame metadata, transcript entries, and key grant/request shapes.

### 1.2 State model & invariants

- [x] 1.2.1 Decide how to map SFU state:
  - `participants: Map<participantId, SfuParticipant>`.
  - `tracks: Map<trackId, SfuTrack>`.
  - `subscriptions: Map<trackId, Set<participantId>>`.
  - `authState: Set<participantId>` for successfully authenticated participants.
- [x] 1.2.2 Document invariants in comments:
  - Only authenticated participants can publish or subscribe.
  - Subscriptions must reference existing tracks.
  - Participants must be in `expected_participants` (when corpus specifies).
  - Track → publisher mapping is one-to-one (duplicate routes flagged).
- [x] 1.2.3 Add event logging/auditing hooks for SFU events:
  - `sfu:join`, `sfu:leave`, `sfu:publish`, `sfu:subscribe`, `sfu:frame:routed`, `sfu:frame:dropped`, etc.
  - Notes (2025-12-09): `sfu.ts` holds maps/sets + metrics; class-level doc lists invariants; log/audit hooks fire for join/leave/publish/subscribe/transcript and key grant events.

**Artifacts:**
- `servers/minimal-js/src/sfu.ts` with a fully-typed skeleton and comments.

---

## 2. SFU Authentication ("Implement SFU authentication")

**Goal:** Implement SFU-side verification of client auth tokens per v0.8.1 spec and expose a simple API for the handler.

### 2.1 Key derivation and token validation helpers

- [x] 2.1.1 Add a crypto helper module in `servers/minimal-js/src/crypto/sfu_auth.ts`:
  - `deriveClientSfuAuthKey(handshakeSecret: Buffer, clientId: string): Buffer` implementing:
    - `HKDF(handshake_secret, salt=0x00, info="FW-SFU-ClientAuth" || client_id, L=32)` **via the same HKDF wrapper used elsewhere in minimal-js** (no SFU-specific variant).
  - `makeClientAuthToken(key, { callId, clientId, timestamp, nonce })` → HMAC-SHA256.
  - For SFU-side reference handler:
    - `verifyClientAuthToken(clientKeyOrSecret, token, context)` returning `boolean` + error code if invalid.
  - Notes (2025-12-09): Implemented `sfu_auth.ts` with HKDF(label), token make/verify (HMAC-SHA256, skew window, nonce replay cache) and typed verify result.
- [x] 2.1.2 Decide how the SFU obtains `client_sf_auth_key` and `sfu_secret_key` in this reference:
  - Minimal approach: handler accepts **pre-derived** `client_sf_auth_key` / `sfu_secret_key` from test inputs rather than deriving from real `handshake_secret`.
  - Document clearly that in real integration these keys come from `handshake_secret` and SFU identity material.
  - Notes (2025-12-09): `SfuConfig` now allows `clientAuthKey`/`sfuSecretKey`; tests use pre-derived buffers.

### 2.2 SFU handler integration

- [x] 2.2.1 Extend `MinimalSfu` to maintain auth state:
  - `authenticate(participantId, tokenContext)` method:
    - Validates provided token with `verifyClientAuthToken`.
    - On success: add to `authState`; on failure: record `IMPERSONATION` or `UNAUTHORIZED_SUBSCRIBE` equivalent.
  - `join()` should enforce successful auth before admitting participant.
- [x] 2.2.2 Implement replay and expiry window:
  - Maintain an in-memory cache of `(participantId, nonce)` with timestamps.
  - Reject reused nonces and tokens outside ±Δ skew (configurable, e.g., `SFU_TOKEN_MAX_SKEW_MS`).
- [x] 2.2.3 Wire auth errors to error codes used in corpus/oracle:
  - Map invalid token attempts to `"IMPERSONATION"` or `"UNAUTHORIZED_SUBSCRIBE"` depending on context.
  - Notes (2025-12-09): `MinimalSfu.authenticate` now calls `verifyClientAuthToken` with nonce cache + skew; maps MAC failures to `IMPERSONATION`, replay/expiry to `UNAUTHORIZED_SUBSCRIBE`, increments unauthorized metrics, and requires configured `clientAuthKey`/`sfuSecretKey`.

### 2.3 Unit tests

- [x] 2.3.1 Add `servers/minimal-js/test/sfu_auth.test.ts` with cases:
  - Valid token accepted; invalid MAC rejected.
  - Expired token rejected.
  - Replay (same token/nonce) rejected.
- [x] 2.3.2 Ensure tests use deterministic keys and timestamps for repeatability.
  - Notes (2025-12-09): `sfu_auth.test.ts` covers valid/invalid MAC, expiry window, and nonce replay with fixed timestamps/keys.

**Artifacts:**
- `servers/minimal-js/src/crypto/sfu_auth.ts`.
- `servers/minimal-js/test/sfu_auth.test.ts`.

---

## 3. Media Key Distribution ("Implement media key distribution")

**Goal:** Implement a minimal but realistic flow for distributing media key material (or handles) via the SFU while preserving end-to-end guarantees.

### 3.1 Key distribution model

- [x] 3.1.1 Decide SFU’s visibility level:
  - SFU knows **key identifiers** and per-participant entitlements, but not raw frame keys.
  - SFU may route encrypted key blobs or key IDs provided by controller/group layer.
- [x] 3.1.2 Define message/struct shapes for key interactions (internal):
  - `SfuKeyGrant { callId, participantId, mediaEpoch, keyId, encryptedKeyBlob? }`.
  - `SfuKeyRequest { callId, participantId, reason }`.

### 3.2 Handler implementation

- [x] 3.2.1 Extend `MinimalSfu` with key distribution methods:
  - `grantMediaKey(grant: SfuKeyGrant)` – records which participant can access which key.
  - `requestMediaKey(participantId, keyId)` – returns grant or denies with error.
- [x] 3.2.2 Ensure enforcement:
  - Only authenticated participants can request keys.
  - Grants are scoped to `callId` and (when applicable) `mediaEpoch` / room; cross-call/epoch/room key reuse is rejected and counted as `KEY_LEAK_ATTEMPT`.
- [x] 3.2.3 Integrate with media vectors where SFU appears:
  - For any test vector that includes SFU media distribution fields, build a small harness that feeds those into `MinimalSfu` and checks that:
    - Authorized participants receive key material (or IDs).
    - Unauthorized participants are denied with proper error metrics.

### 3.3 Tests & artifacts

- [x] 3.3.1 Add `servers/minimal-js/test/sfu_keys.test.ts`:
  - Direct-unit tests for `grantMediaKey`/`requestMediaKey`.
  - Vector-driven tests referencing `tests/common/handshake/media_encryption_test_vectors.json` where applicable.
- [x] 3.3.2 Emit a digest-only status artifact (similar to `key_schedule_status.json`):
  - `clients/minimal-js/test-output/sfu_key_distribution_status.json` (or `servers/minimal-js/test-output/...`) summarizing pass/fail per vector.
  - Notes (2025-12-09): Vector harness `test/sfu_keys_vectors.test.ts` writes `servers/minimal-js/test-output/sfu_key_distribution_status.json`; artifact exists—CI wiring added via validate scripts, but workflow still to pick artifacts.

**Artifacts:**
- `servers/minimal-js/src/sfu.ts` key-distribution logic.
- `servers/minimal-js/test/sfu_keys.test.ts` and `servers/minimal-js/test/sfu_keys_vectors.test.ts`.
- `servers/minimal-js/test-output/sfu_key_distribution_status.json`.

---

## 4. Stream Routing & Participant Management ("Implement stream routing logic" + "Implement participant management")

**Goal:** Implement SFU’s routing and participant lifecycle with abuse guardrails matching the SFU abuse corpus/oracles.

### 4.1 Participant lifecycle

- [x] 4.1.1 Implement `join` and `leave` in `MinimalSfu`:
  - `join`:
    - Requires valid auth state (see Section 2).
    - Registers participant in `participants` map and ensures they are in `expected_participants` when provided.
  - `leave`:
    - Removes participant, subscriptions, and any tracks they own.
- [x] 4.1.2 Ensure idempotency:
  - Multiple `join` calls for the same participant should be safe and log `sfu:join:dup`.
  - `leave` on non-present participant should be a no-op with a log entry.

### 4.2 Tracks and subscriptions

- [x] 4.2.1 Implement `publishTrack`:
  - Validate participant is authenticated and joined.
  - Register `trackId → participantId`, allowed layers, and any bitrate limits.
  - Reject publishing if track already exists; count as `DUPLICATE_ROUTE`.
- [x] 4.2.2 Implement `subscribeTrack`:
  - Validate subscriber is authenticated, in room, and track exists.
  - Enforce layer constraints, rejecting requests that exceed allowed layers as `SIMULCAST_SPOOF`.
  - Enforce any per-participant or per-track limits (e.g., max subscriptions per track).
  - Return a structured result: `"allowed" | "denied"` plus an error code if denied.

### 4.3 Abuse guardrails

- [x] 4.3.1 Implement event handlers in `MinimalSfu` that conceptually mirror SFU abuse events:
  - `ghost_subscribe` → treat as subscription attempt by unknown participant; record `UNAUTHORIZED_SUBSCRIBE`.
  - `impersonate` → detect mismatched tokens/IDs; record `IMPERSONATION`.
  - `replay_track` → repeated track use beyond policy; `REPLAY_TRACK`.
  - `dup_track` → `DUPLICATE_ROUTE`.
  - `bitrate_abuse` → `BITRATE_ABUSE`.
  - `key_rotation_skip` / `stale_key_reuse` → `STALE_KEY_REUSE`.
  - `steal_key` → `KEY_LEAK_ATTEMPT`.
- [x] 4.3.2 Maintain counters and metrics aligned with oracles:
  - `unauthorized_tracks`, `hijacked_tracks`, `key_leak_attempts`, `duplicate_routes`, `replayed_tracks`, `simulcast_spoofs`, `bitrate_abuse_events`, etc.

### 4.4 Test harness integration with SFU abuse corpus

- [x] 4.4.1 Add a small adapter that replays SFU abuse scenarios against `MinimalSfu` instead of the pure-simulator shim:
  - New file: `servers/minimal-js/test/sfu_abuse_harness.test.ts`.
  - For each scenario in `tests/common/adversarial/sfu_abuse.json`:
    - Instantiate `MinimalSfu` with matching `sfu_context`.
    - Replay `timeline` events, mapping them to handler calls.
    - Collect `errors` and `metrics` from `MinimalSfu` and compare with expectations using the same logic as `validation/common/simulators/sfu_abuse.py` / `validation/nodejs/validators/sfu_abuse.js`.
- [x] 4.4.2 Ensure that SFU abuse validator and reference handler share error codes and metric semantics.
  - Notes (2025-12-09): Harness uses `MinimalSfu` with policy `acceptAnyToken` for corpus tokens, maps events (ghost/impersonate/replay/dup/simulcast_spoof/bitrate_abuse/stale_key_reuse/steal_key) to MinimalSfu methods, and enforces expected errors/metric ceilings against the corpus; error union shared via `sfu_types.ts`.

**Artifacts:**
- `servers/minimal-js/src/sfu.ts` participant/track logic.
- `servers/minimal-js/test/sfu_abuse_harness.test.ts`.

---

## 5. Media Transcript Integrity ("Add media transcript integrity")

**Goal:** Capture a verifiable, privacy-preserving transcript of SFU routing decisions.

### 5.1 Transcript format definition

- [x] 5.1.1 Define a transcript schema (documented in-code and in docs):
  - A transcript entry contains **only digests, IDs, and error codes**; no raw headers, payloads, or keys:
    - `call_id`, `room_id`, `sfu_id`.
    - `participant_id` (publisher), `subscriber_ids`.
    - `track_id`, `media_epoch`, `frame_sequence` range.
    - `routing_action` (routed/dropped/denied), `reason` (error code when denied).
    - `header_digest` = `SHA256(canonicalCBOR(frame_header || routing_metadata))` (can reuse or extend the AAD digest already used in media mode).
- [x] 5.1.2 Decide where transcripts are stored for tests:
  - In-memory collection with ability to export as JSON (`SfuTranscriptExporter`).
  - Output file for CI: `servers/minimal-js/test-output/sfu_media_transcript.json` (or similar).
  - Notes (2025-12-09): Transcript stays in-memory but `sfu_transcript.test.ts` writes `servers/minimal-js/test-output/sfu_media_transcript.json` during test runs; CI wiring pending for artifact upload.

### 5.2 Implementation in handler

- [x] 5.2.1 Add transcript-recording hooks to `MinimalSfu`:
  - On every routed or dropped frame, emit a transcript entry.
  - Ensure no key material or plaintext payloads are recorded, only digests.
- [x] 5.2.2 Provide methods to:
  - `getTranscript()` – returns in-memory entries for tests.
  - `resetTranscript()` – clears captured entries (for isolation between tests).

### 5.3 Tests & validation

- [x] 5.3.1 Add `servers/minimal-js/test/sfu_transcript.test.ts`:
  - Verify that all routed frames have transcript entries.
  - Verify that denied/unauthorized frames either:
    - Have transcript entries with `routing_action = "denied"`, or
    - Are intentionally excluded (document the choice and enforce consistently).
- [x] 5.3.2 Cross-check against abuse corpus:
  - For selected SFU abuse scenarios, assert that transcript entries reflect detected abuse (e.g., `UNAUTHORIZED_SUBSCRIBE` events).
  - Notes (2025-12-09): `sfu_abuse_transcript.test.ts` replays ghost/impersonate scenario and asserts denied transcript entries; CI artifact still pending.

**Artifacts:**
- Transcript logic in `servers/minimal-js/src/sfu.ts`.
- `servers/minimal-js/test/sfu_transcript.test.ts` and `servers/minimal-js/test/sfu_abuse_transcript.test.ts`.

---

## 6. CI Integration, Docs & Security Validation ("Create SFU deployment guide" + "Validate media security properties")

**Goal:** Wire SFU handler into CI, document how to run/deploy it, and explicitly validate media security properties.

### 6.1 CI wiring

- [x] 6.1.1 Add SFU tests to Node validation scripts:
  - Update `scripts/jobs/validate-nodejs.sh` to run `npm test` (or specific vitest suites) in `servers/minimal-js` including SFU tests.
  - Ensure SFU-related artifacts (e.g., `sfu_abuse_status.json`, `sfu_key_distribution_status.json`, `sfu_transcript_status.json`) are written to predictable locations under `servers/minimal-js/test-output/`.
  - Notes (2025-12-09): `validate-ci-simple.sh` and `scripts/jobs/validate-nodejs.sh` now run `npm test` in `servers/minimal-js`; artifacts land under `servers/minimal-js/test-output/`.
- [x] 6.1.2 Integrate SFU checks into higher-level CI:
  - Update `.github/workflows/validation.yml` and/or `scripts/validate-ci-simple.sh` / `scripts/validate-ci-nested.sh` to include SFU-level checks as part of Node jobs.
  - Notes (2025-12-09): workflow now runs `scripts/jobs/validate-nodejs.sh` which executes `npm test` in `servers/minimal-js` and uploads `servers/minimal-js/test-output/*` artifacts; validate-ci-simple also runs SFU tests.

### 6.2 SFU deployment guide (docs)

- [ ] 6.2.1 Create `docs/sfu-reference-handler-deployment.md` covering:
  - Topology diagrams: minimal client ↔ minimal server ↔ SFU handler.
  - Required configuration (env vars, `SfuConfig`, auth token requirements).
  - Example dev setup:
    - Start minimal server + SFU in-process.
    - Start two clients exchanging media frames with SFU auth enabled.
- [ ] 6.2.2 Add operational caveats:
  - Emphasize test/reference nature (not hardened for production).
  - Note need for TLS termination, real identity management, rate limiting, and observability in real deployments.

### 6.3 Media security properties

- [ ] 6.3.1 Write a brief security note (could be a section in the deployment guide or a separate short doc) that maps SFU behavior to the v0.8.1 threat model:
  - SFU sees routing metadata and digests only; no plaintext frames or keys.
  - Unauthorized participants cannot obtain keys or frame routing (backed by tests).
  - SFU compromise does not break end-to-end confidentiality, only metadata privacy.
- [ ] 6.3.2 Tie tests to security claims:
  - For each key high-level claim, reference at least one SFU test case / corpus scenario that exercises it.

**Artifacts:**
- Updated CI scripts referencing SFU tests.
- `docs/sfu-reference-handler-deployment.md`.
- Short security properties section tied to tests.

---

## 7. Completion Checklist for 4.3.3

These correspond to the original bullets in `v0.9-comprehensive-todo-list` §4.3.3 and should only be ticked when the underlying sub-tasks in this document are complete.

- [x] **Design SFU architecture**
  - Covered by sections 0, 1, and the design note.
- [x] **Implement SFU authentication**
  - Covered by section 2.
- [x] **Implement media key distribution**
  - Covered by section 3.
- [x] **Implement stream routing logic**
  - Covered by section 4 (tracks + subscriptions + abuse guardrails).
- [x] **Implement participant management**
  - Covered by section 4.1 and 4.2.
- [x] **Add media transcript integrity**
  - Covered by section 5.
- [ ] **Create SFU deployment guide**
  - Covered by section 6.2.
- [ ] **Validate media security properties**
  - Covered by section 6.3 and associated tests.

Notes / Pending Reviews
1 (Sections 3.3.2 & 5.1.2): Confirm GitHub Actions uploads the SFU artifacts `servers/minimal-js/test-output/sfu_key_distribution_status.json` and `servers/minimal-js/test-output/sfu_media_transcript.json`; align schema with other *_status.json artifacts if needed.
2 (Sections 6.2 & 6.3): Still need the SFU deployment guide and security properties note tying tests to claims.
